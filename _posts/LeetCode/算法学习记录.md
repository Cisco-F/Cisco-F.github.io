## 算法学习记录

### 动态规划

1. 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

	你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

	返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

	> 示例1：
	>
	> ```
	> 输入：[7,1,5,3,6,4]
	> 输出：5
	> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
	> 			注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
	> ```
	>
	> 示例2
	>
	> ```
	> 输入：prices = [7,6,4,3,1]
	> 输出：0
	> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
	> ```

	**答案**

	```c
	int maxProfit(int* prices, int pricesSize){
	    int maxprofit = 0;
	    for(int i = 0; i < pricesSize; i++)
	    {
	        if(prices[i] < minprice)
	            minprice = prices[i];
	        if(prices[i] - minprice > maxprofit)
	            maxprofit = prices[i] - minprice;
	    }
	    return maxprofit;
	}
	```

	时刻更新当前遇到的股票价格最小值和能获取的最大利润，每读入新数据时计算最大利润，并在每一天计算，如果是在股价最低时买入股票所能获得的利润。

### 异或运算

两个不同的数异或运算结果为1，两个相同的数异或运算结果为0

> 性质：
>
> 1. 任何数和 00 做异或运算，结果仍然是原来的数
> 2. 任何数和其自身做异或运算，结果是 0
> 3. 异或运算满足交换律和结合律

***

1. 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

	你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

	> 示例1：
	>
	> ```
	> 输入：nums = [2,2,1]
	> 输出：1
	> ```
	>
	> 示例2：
	>
	>  ```
	>  输入：nums = [4,1,2,1,2]
	>  输出：4
	>  ```
	>
	> 示例3：
	>
	> ```
	> 输入：nums = [1]
	> 输出：1
	> ```

	**答案**

	```c
	int singleNumber(int* nums, int numsSize){
	    int ret = 0; 
	    for(int i = 0; i < numsSize; i++)
	    {
	        ret = ret ^ nums[i];
	    }
	    return ret;
	}
	```

	**^**为位异或运算操作符，会先将操作数转换为二进制数，每一位分别异或得到结果。因为异或满足交换律，故此方法可行。

### 摩尔投票法

1. 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

	你可以假设数组是非空的，并且给定的数组总是存在多数元素。

	> 示例1：
	>
	> ```
	> 输入：nums = [3,2,3]
	> 输出：3
	> ```
	>
	> 示例2：
	>
	> ```
	> 输入：nums = [2,2,1,1,1,2,2]
	> 输出：2
	> ```

	**答案**

	```c
	int majorityElement(int* nums, int numsSize){
	    int major = nums[0];
	    int cnt = 1;
	    for(int i = 1; i < numsSize; i++)
	    {
	        if(nums[i] == major)
	        	cnt++;
	        else
	        	cnt--;
	        if(cnt < 0)
	        {
	            major = nums[i];
	            cnt = 1;
	        }
	    }
	    return major;
	}
	```

	假设数组各元素代表某人得票数，摩尔投票法即采用相互抵消的方法，cnt记录当前候选人得票数，遍历数组与候选人一致则cnt++，否则cnt--；当cnt小于0时说明当前候选人票数不足和大于一半的人相抵消，故更新候选人，并将cnt重置为1.因为题目限制了总是存在多数元素，即总有数字出现了大于[n/2]次，所以方法可行。



